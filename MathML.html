<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <title>MathML - 数式処理</title>
    <script src="https://www.promisejs.org/polyfills/promise-7.0.4.min.js"></script>
    <script data-main="./src/main" src="require.js"></script>

    <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/javascript" src="./src/main.js?ver=226"></script>
    <script type="text/javascript">
    var typeset_done = false;

    function element(id){
        return document.getElementById(id);
    }

    function makeDiv(inner_text){
        var div = document.createElement("div");
        div.innerText = inner_text;
        document.body.appendChild(div);

        return div;
    }

    function makeMath(tag){
        return document.createElementNS("http://www.w3.org/1998/Math/MathML", tag);
    }

    function mmlDiv(s){
        var m = makeMath("math");
        m.innerHTML = s;

        var div = document.createElement("div");
        div.appendChild(m);
        document.body.appendChild(div);

        return div;
    }

    function hr(){
        document.body.appendChild(document.createElement("hr"));
    }

    function* moveTo(src, dst){
        var src_rc = src.getBoundingClientRect();

        var rc1 = dst.getBoundingClientRect();

        var div = src.cloneNode(true);
        div.style.position = "absolute";
        div.style.left = src_rc.x + "px";
        div.style.top  = src_rc.y + "px";
        
        document.body.appendChild(div);
        var rc2 = div.getBoundingClientRect();

        var sc = Math.max(rc1.width / rc2.width, rc1.height / rc2.height);

        // 移動先の中心
        var cx1 = rc1.x + rc1.width / 2;
        var cy1 = rc1.y + rc1.height / 2;

        // 移動元の中心
        var cx2 = rc2.x + rc2.width / 2;
        var cy2 = rc2.y + rc2.height / 2;

        // 移動元のサイズ
        var w2 = rc2.width;
        var h2 = rc2.height;

        // 平行移動の差分
        var dx = (cx1 - cx2) / 100;
        var dy = (cy1 - cy2) / 100;

        // サイズ変更の差分
        var ds = (sc - 1) / 100;

        pushInterval(20);
        for(var i = 0; i < 100; i++){

            var r = 1 + i * ds;

            div.style.transform = "scale(" + r + "," + r + ")";

            div.style.left = (cx2 + i * dx - w2/2) + "px";
            div.style.top  = (cy2 + i * dy - h2/2) + "px";

            yield;
        }
        div.parentNode.removeChild(div);
        popInterval();
    }

    function waitTypeset(){
        typeset_done = false;
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
        MathJax.Hub.Queue(function(){
            typeset_done = true;
        });
    }

    function* generator(){

        var lex = new Lex();
        var parser = new Parser();

        var token_list = lex.lexicalAnalysis( element("math-txt").value );
        var stmt_list = parser.parse(token_list);

        var text = stmt_list.map(x => x.mathML()).join("<mspace linebreak='newline' />");
        mmlDiv(text);
        hr();

        mmlDiv(stmt_list[0].clone().mathML());
        hr();

        var sc = new SymbolicComputation();
        var t1 = stmt_list[0].clone();
        var uv = stmt_list[1];

        // x -> u + v
        t1.setDisplayText();
        sc.SubstByName(t1, "x", uv);
        var t1_div = mmlDiv(t1.mathML());
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("x -> u + v");

        // f -> g
        var t2 = stmt_list[0].clone();
        t2.setDisplayText();
        sc.SubstByName(t2, "f", new Reference("g"));
        mmlDiv(t2.mathML());
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("f -> g");

        // f -> u + v
        var t3 = stmt_list[0].clone();
        t3.setDisplayText();
        sc.SubstByName(t3, "f", uv);
        mmlDiv(t3.mathML());
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("f -> u + v");


        // u + v -> F * G
        var FG = parse("F * G;");
        var t4 = t3.clone();
        t4.setDisplayText();
        sc.ReplaceTerm(t4, uv, FG);
        mmlDiv(t4.mathML());
        hr();

        for(waitTypeset(); ! typeset_done; yield);
        console.log("");

        var refs = sc.RefsByName(t4, "x");
        console.log(refs.map(x => element(x.id)));
        for(let e of refs.map(x => element(x.id))){
            e.style.color = "red";
        }
        for(var it = moveTo(t1_div, element(refs[0].id)); ! it.next().done; yield);
        yield;

        var src = mmlDiv(element("src-txt").value);
        src.style.transform = "scale(1,1)";
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("src-txt");

        var dst = mmlDiv(element("dst-txt").value);
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("dst-txt");

        for(var it = moveTo(src, element("x1")); ! it.next().done; yield);
    }

    var timerId = null;
    var timerIntervals = [];
    var iterator;

    function timerFnc(){
        if(iterator.next().done){
            // ジェネレータが終了した場合

            clearInterval(timerId);
            console.log("ジェネレータ 終了");
        }
    }

    function pushInterval(interval){
        if(timerId != null){

            clearInterval(timerId);
        }

        timerIntervals.push(interval);
        timerId = setInterval(timerFnc, interval);
    }

    function popInterval(){
        timerIntervals.pop();
        clearInterval(timerId);
        
        var interval = timerIntervals.pop();
        timerId = setInterval(timerFnc, interval);
    }

    function BodyOnLoad(){
        iterator = generator();

        pushInterval(2000);
    }
    </script>    
</head>
<body onload="BodyOnLoad()">

<textarea cols="1" rows="1" id="src-txt">
    <mi>X</mi>
    <mo>=</mo>
    <mn>8</mn>
    <mfrac>
        <mn>9</mn>
        <mi>X</mi>
    </mfrac>
</textarea>

<textarea cols="1" rows="1" id="dst-txt">
    <msqrt>
        <mn>2</mn>
    </msqrt>

    <mo>&middot;</mo>
    <msup>
        <mi>x</mi>
        <mn>2</mn>
    </msup>

    <mo>&middot;</mo>
    <msub>
        <mi>x</mi>
        <mn>2</mn>
    </msub>

    <mo>&middot;</mo>
    <msubsup>
        <mo>&int;</mo>
        <mn>0</mn>
        <mn>1</mn>
    </msubsup>
    <mi>sin</mi><mo>&af;</mo><mi>x</mi>
    <mi>d</mi><mi>x</mi>

    <mo>&middot;</mo>
    <munder>
        <mo>lim</mo>
        <mrow>
            <mi>n</mi><mo>&rarr;</mo><mi>&infin;</mi>
        </mrow>
    </munder>
    <mi>f</mi>
    <mo>&af;</mo>
    <mfenced>
        <mi id='x1'>&Phi;</mi>
    </mfenced>
    <mo>=</mo>
    <mn>0</mn>

    <mo>&middot;</mo>
    <munderover>
        <mo>&Sum;</mo>
        <mrow>
            <mi>k</mi><mo>=</mo><mn>0</mn>
        </mrow>
        <mi>&infin;</mi>
    </munderover>
    <msub>
        <mi>a</mi>
        <mi>k</mi>
    </msub>

    <mo>&middot;</mo>
    <mi>x</mi>
    <mo>&isin;</mo>
    <mi>X</mi>
</textarea>

<textarea cols="1" rows="1" id="math-txt">
    dif(f(x),x) = lim(Delta, 0, (f(x+Delta) - f(x)) / Delta );
    u + v;
    (f + g)(x) = f(x) + g(x);
    var a : int, b : int;
    sqrt(x/y) * int(x, (a*b)/(a+b), N, 2 * sqrt(x/y))
        = - a[i,j] + 3 * a[i,j] -3 * a[i,j] + a / (b + c) + a[i] + p[i[j]] * 2 + abc + p[i,j] * 2 + sum(i, 0, N, p[i]);
    y(x, w) = sum(j, 0, M, w[j] * x^j) + (1 / 2) * sum(n, 1, N, (y(x[n],w) - t[n])^2) 
        = E[RMS] = sqrt((2 * E(w__lowast))/N)
        = E__tilde(w) = (1 / 2) * sum(n, 1, N, (y(x[n],w) - t[n])^2) + (lambda/2) * norm(w)^2;
</textarea>
    
</body>
</html>