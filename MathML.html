<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <title>MathML - 数式処理</title>
    <script src="https://www.promisejs.org/polyfills/promise-7.0.4.min.js"></script>
    <script data-main="./src/main" src="require.js"></script>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            extensions: [ "tex2jax.js", "mml2jax.js" ],
            jax: ["input/TeX", "input/MathML", "output/SVG"],
        })
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=default"></script>
    <script type="text/javascript" src="./src/main.js?ver=226"></script>
<script type="text/javascript">
    var typeset_done = false;

    function element(id){
        return document.getElementById(id);
    }

    function makeDiv(inner_text){
        var div = document.createElement("div");
        div.innerText = inner_text;
        document.body.appendChild(div);

        return div;
    }

    function makeMath(tag){
        return document.createElementNS("http://www.w3.org/1998/Math/MathML", tag);
    }

    function mmlDiv(s){
        var m = makeMath("math");
        m.innerHTML = s;

        var div = document.createElement("div");
        div.appendChild(m);
        document.body.appendChild(div);

        return div;
    }

    function hr(){
        document.body.appendChild(document.createElement("hr"));
    }

    function* moveTo(src, dst){
        var src_rc = src.getBoundingClientRect();

        var rc1 = dst.getBoundingClientRect();

        var div = src.cloneNode(true);
//        var style = window.getComputedStyle(src);
        div.style.position = "absolute";
        div.style.left = src_rc.x + "px";
        div.style.top  = src_rc.y + "px";
//        div.style.width  = style.width;
//        div.style.height  = style.height;
        
        document.body.appendChild(div);
        yield;
        var rc2 = div.getBoundingClientRect();

        var sc = Math.max(rc1.width / rc2.width, rc1.height / rc2.height);

        // 移動先の中心
        var cx1 = rc1.x + rc1.width / 2;
        var cy1 = rc1.y + rc1.height / 2;

        // 移動元の中心
        var cx2 = rc2.x + rc2.width / 2;
        var cy2 = rc2.y + rc2.height / 2;

        // 移動元のサイズ
        var w2 = rc2.width;
        var h2 = rc2.height;

        // 平行移動の差分
        var dx = (cx1 - cx2) / 100;
        var dy = (cy1 - cy2) / 100;

        // サイズ変更の差分
        var ds = (sc - 1) / 100;

        pushInterval(10);
        for(var i = 0; i < 100; i++){

            var r = 1 + i * ds;

            div.style.transform = "scale(" + r + "," + r + ")";

            div.style.left = (cx2 + i * dx - w2/2) + "px";
            div.style.top  = (cy2 + i * dy - h2/2) + "px";

            yield;
        }
        div.parentNode.removeChild(div);
        popInterval();
    }

    function waitTypeset(){
        typeset_done = false;
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
        MathJax.Hub.Queue(function(){
            typeset_done = true;
        });
    }

    function setColor(color, ...ids){
        for(let id of ids){
            element(id).style.color = color;
        }
    }

    var divs = [];

    function remove(idx){
        if(idx < 0){
            idx += divs.length;
        }
        var div = divs[idx];
        div.parentNode.removeChild(div);
    }

    function msg(txt){
        var span = document.createElement("span");
        span.innerText = txt;
        document.body.appendChild(span);
        document.body.appendChild(document.createElement("br"));
    }

    function* scaleUp(div){
        var r = 0.01;
        pushInterval(1);
        for(var i = 0; i < 100; i++){

            r += 0.01;

            div.style.transform = "scale(" + r + "," + r + ")";

            yield;
        }
        popInterval();
    }

    function* generator(){

        var lex = new Lex();
        var parser = new Parser();

        // 積の微分
        pushInterval(1000);
        for(var line of element("mul-dif").value.split('\n')){
            line = line.trim();
            if(line == ""){

                yield;
                continue;
            }
            if(line[0] == '$'){
                eval(line.substring(1).trim());
            }
            else if(line[0] == '#'){
                pushInterval(3000);
                for(waitTypeset(); ! typeset_done; yield);
                popInterval();
                
                var ids = line.split("-");
                for(var it = moveTo(element(ids[0].trim()), element(ids[1].trim())); ! it.next().done; yield);
            }           
            else{

                var stmt = parse(line);

                var div = mmlDiv( stmt.mathML() );
                div.style.transform = "scale(0.01, 0.01)";

                divs.push(div);
                pushInterval(1);
                for(waitTypeset(); ! typeset_done; yield);
                popInterval();

                for(var it = scaleUp(div); ! it.next().done; yield);
                
            }
        }
        popInterval();



        var token_list = lex.lexicalAnalysis( element("math-txt").value );
        var stmt_list = parser.parse(token_list);

        var sc = new SymbolicComputation();
        var t1 = stmt_list[0].clone();
        var uv = parse("u+v;");

        // x -> u + v
        t1.setDisplayText();
        sc.SubstByName(t1, "x", uv);
        var t1_div = mmlDiv(t1.mathML());
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("x -> u + v");

        // f -> g
        var t2 = stmt_list[0].clone();
        t2.setDisplayText();
        sc.SubstByName(t2, "f", new Reference("g"));
        mmlDiv(t2.mathML());
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("f -> g");

        // f -> u + v
        var t3 = stmt_list[0].clone();
        t3.setDisplayText();
        sc.SubstByName(t3, "f", uv);
        mmlDiv(t3.mathML());
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("f -> u + v");


        // u + v -> F * G
        var FG = parse("F * G;");
        var t4 = t3.clone();
        t4.setDisplayText();
        sc.ReplaceTerm(t4, uv, FG);
        mmlDiv(t4.mathML());
        hr();

        for(waitTypeset(); ! typeset_done; yield);
        console.log("");

        var refs = sc.RefsByName(t4, "x");
        console.log(refs.map(x => element(x.id)));
        for(let e of refs.map(x => element(x.id))){
            e.style.color = "red";
        }
        for(var it = moveTo(t1_div, element(refs[0].id)); ! it.next().done; yield);
        yield;

        var src = mmlDiv(element("src-txt").value);
        src.style.transform = "scale(1,1)";
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("src-txt");

        var dst = mmlDiv(element("dst-txt").value);
        hr();
        for(waitTypeset(); ! typeset_done; yield);
        console.log("dst-txt");

        for(var it = moveTo(src, element("x1")); ! it.next().done; yield);

        var text = stmt_list.map(x => x.mathML()).join("<mspace linebreak='newline' />");
        mmlDiv(text);
        hr();
        for(waitTypeset(); ! typeset_done; yield);
    }

    var timerId = null;
    var timerIntervals = [];
    var iterator;

    function timerFnc(){
        if(iterator.next().done){
            // ジェネレータが終了した場合

            clearInterval(timerId);
            console.log("ジェネレータ 終了");
        }
    }

    function pushInterval(interval){
        if(timerId != null){

            clearInterval(timerId);
        }

        timerIntervals.push(interval);
        timerId = setInterval(timerFnc, interval);
    }

    function popInterval(){
        timerIntervals.pop();
        clearInterval(timerId);
        
        var interval = timerIntervals[timerIntervals.length - 1];
        timerId = setInterval(timerFnc, interval);
    }

    function BodyOnLoad(){
        iterator = generator();

        pushInterval(1000);
    }
</script>    
</head>
<body onload="BodyOnLoad()">


<!--
    (f*g)(x+Delta) = #1.2{f(x+Delta)*g(x+Delta)} / 3;
    
    #1.2-#3

    3 * (a + b);
-->

<textarea style="display: none" cols="1" rows="1" id="mul-dif">
    dif((f*g)(x),x);

    lim(Delta, 0, ( #1.1{(f*g)(x+Delta)} - #1.2{(f*g)(x)} ) / Delta );

    $ msg("関数の積の定義");
    $ setColor("red", "#1.1", "#1.2");

    lim(Delta, 0, ( (f*g)( #3{x} +Delta) - (f*g)(x) ) / Delta );

    lim(Delta, 0, (#2.1{f(x+Delta)*g(x+Delta)} - #2.2{f(x)*g(x)}) / Delta );
    $ setColor("red", "#2.1", "#2.2");

    $ setColor("black", "#2.1", "#2.2");

    lim(Delta, 0, (f(x+Delta)*g(x+Delta) - #3.1{f(x+Delta)*g(x)} + #3.2{f(x+Delta)*g(x)} - f(x)*g(x)) / Delta );
    $ setColor("red", "#3.1", "#3.2");

    lim(Delta, 0, (f(x+Delta)*g(x+Delta) - f(x+Delta)*g(x)) / Delta ) + lim(Delta, 0, ( f(x+Delta)*g(x) - f(x)*g(x) ) / Delta );

    lim(Delta, 0, f(x+Delta)*((g(x+Delta) - g(x)) / Delta)) + lim(Delta, 0, ( f(x+Delta) - f(x) ) / Delta )*g(x);

    lim(Delta, 0, f(x+Delta)) * lim(Delta, 0, (g(x+Delta) - g(x)) / Delta) + lim(Delta, 0, ( f(x+Delta) - f(x) ) / Delta )*g(x);

    f(x) * dif(g(x),x) + dif(f(x),x) * g(x);
</textarea>

<textarea style="display: none" cols="1" rows="1" id="src-txt">
    <mi>X</mi>
    <mo>=</mo>
    <mn>8</mn>
    <mfrac>
        <mn>9</mn>
        <mi>X</mi>
    </mfrac>
</textarea>

<textarea style="display: none" cols="1" rows="1" id="dst-txt">
    <msqrt>
        <mn>2</mn>
    </msqrt>

    <mo>&middot;</mo>
    <msup>
        <mi>x</mi>
        <mn>2</mn>
    </msup>

    <mo>&middot;</mo>
    <msub>
        <mi>x</mi>
        <mn>2</mn>
    </msub>

    <mo>&middot;</mo>
    <msubsup>
        <mo>&int;</mo>
        <mn>0</mn>
        <mn>1</mn>
    </msubsup>
    <mi>sin</mi><mo>&af;</mo><mi>x</mi>
    <mi>d</mi><mi>x</mi>

    <mo>&middot;</mo>
    <munder>
        <mo>lim</mo>
        <mrow>
            <mi>n</mi><mo>&rarr;</mo><mi>&infin;</mi>
        </mrow>
    </munder>
    <mi>f</mi>
    <mo>&af;</mo>
    <mfenced>
        <mi id='x1'>&Phi;</mi>
    </mfenced>
    <mo>=</mo>
    <mn>0</mn>

    <mo>&middot;</mo>
    <munderover>
        <mo>&Sum;</mo>
        <mrow>
            <mi>k</mi><mo>=</mo><mn>0</mn>
        </mrow>
        <mi>&infin;</mi>
    </munderover>
    <msub>
        <mi>a</mi>
        <mi>k</mi>
    </msub>

    <mo>&middot;</mo>
    <mi>x</mi>
    <mo>&isin;</mo>
    <mi>X</mi>
</textarea>

<textarea style="display: none" cols="1" rows="1" id="math-txt">
    dif(f(x),x) = lim(Delta, 0, (f(x+Delta) - f(x)) / Delta );
    (f + g)(x) = f(x) + g(x);
    var a : int, b : int;
    sqrt(x/y) * int(x, (a*b)/(a+b), N, 2 * sqrt(x/y))
        = - a[i,j] + 3 * a[i,j] -3 * a[i,j] + a / (b + c) + a[i] + p[i[j]] * 2 + abc + p[i,j] * 2 + sum(i, 0, N, p[i]);
    y(x, w) = sum(j, 0, M, w[j] * x^j) + (1 / 2) * sum(n, 1, N, (y(x[n],w) - t[n])^2) 
        = E[RMS] = sqrt((2 * E(w__lowast))/N)
        = E__tilde(w) = (1 / 2) * sum(n, 1, N, (y(x[n],w) - t[n])^2) + (lambda/2) * norm(w)^2;        
</textarea>
    
</body>
</html>